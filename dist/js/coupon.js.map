{"version":3,"sources":["webpack:///coupon.js","webpack:///./src/js/coupon.js","webpack:///./src/js/component/swipe.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","Swipe","$","coupon","init","this","swipe","selectEvent","off","on","hasClass","index","siblings","removeClass","addClass","confirm","next","prev","document","getElementById","speed","continuous","auto","callback","element","$li","find","length","window","12","14","container","options","setup","slides","children","browser","transitions","appendChild","cloneNode","slidePos","Array","width","getBoundingClientRect","offsetWidth","style","pos","slide","setAttribute","left","move","circle","visibility","to","slideSpeed","direction","Math","abs","natural_direction","diff","animate","offloadFn","dist","translate","webkitTransitionDuration","MozTransitionDuration","msTransitionDuration","OTransitionDuration","transitionDuration","webkitTransform","msTransform","MozTransform","OTransform","from","start","Date","timer","setInterval","timeElap","delay","begin","transitionEnd","call","event","clearInterval","floor","interval","setTimeout","stop","clearTimeout","noop","fn","addEventListener","touch","DocumentTouch","temp","props","i","undefined","createElement","parseInt","startSlide","isScrolling","delta","events","handleEvent","type","end","stopPropagation","touches","x","pageX","y","pageY","time","scale","disableScroll","preventDefault","duration","isValidSlide","Number","isPastBounds","removeEventListener","target","getAttribute","supportsOrientationChange","orientationEvent","onresize","getPos","getNumSlides","kill"],"mappings":"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","file":"coupon.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * \n\t * @authors Your Name (you@example.org)\n\t * @date    2017-03-05 14:00:03\n\t * @version $Id$\n\t */\n\t__webpack_require__(1);\n\t__webpack_require__(12); // 载入 style.css\n\t\n\tvar zepto = __webpack_require__(7),\n\t\tSwipe = __webpack_require__(14);\n\t$(function(){\n\t\tvar coupon = {\n\t\t\tinit:function(){\n\t\t\t\tthis.swipe();\n\t\t\t\tthis.selectEvent();\n\t\t\t},\n\t\t\tselectEvent:function(){\n\t\t\t\t$('.tab-list li').off('click').on('click',function(){\n\t\t\t\t\tif($(this).hasClass('cur'))return;\n\t\t\t\t\tvar index = $(this).index();\n\t\t\t\t\t$(this).siblings('li').removeClass('cur');\n\t\t\t\t\t$(this).addClass('cur');\n\t\t\t\t\tindex == 1 ? confirm.swipe.next() : confirm.swipe.prev();\n\t\t\t\t})\n\t\t\t},\t\n\t\t\tswipe:function(){//轮播图效果\n\t\t\t\tconfirm.swipe = Swipe(document.getElementById('J_swipe_wp'),{\n\t\t    \t\tspeed:300,\n\t\t    \t\tcontinuous:false,\n\t\t    \t\tauto:0,\n\t\t    \t\tcallback: function(index, element){\n\t\t    \t\t\tvar $li = $('.tab-list li');\n\t\t    \t\t\t$li.removeClass('cur');\n\t\t    \t\t\t$($li[index]).addClass('cur');\n\t\t    \t\t\t$(element).find('dl').length ? $('body').addClass('hascoupon').removeClass('nocoupon') : $('body').addClass('nocoupon').removeClass('hascoupon');\n\t\t    \t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tcoupon.init();\n\t\twindow.coupon = coupon;\n\t})\n\t\n\t\n\n\n/***/ },\n\n/***/ 12:\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n\n/***/ 14:\n/***/ function(module, exports) {\n\n\t\n\t  /*\n\t * Swipe 2.0\n\t *\n\t * Brad Birdsall\n\t * Copyright 2013, MIT License\n\t *\n\t*/\n\t\n\tmodule.exports =function (container, options) {\n\t\n\t  \"use strict\";\n\t\n\t  // utilities\n\t  var noop = function() {}; // simple no operation function\n\t  var offloadFn = function(fn) { setTimeout(fn || noop, 0) }; // offload a functions execution\n\t\n\t  // check browser capabilities\n\t  var browser = {\n\t    addEventListener: !!window.addEventListener,\n\t    touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,\n\t    transitions: (function(temp) {\n\t      var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\n\t      for ( var i in props ) if (temp.style[ props[i] ] !== undefined) return true;\n\t      return false;\n\t    })(document.createElement('swipe'))\n\t  };\n\t\n\t  // quit if no root element\n\t  if (!container) return;\n\t  var element = container.children[0];\n\t  var slides, slidePos, width, length;\n\t  options = options || {};\n\t  var index = parseInt(options.startSlide, 10) || 0;\n\t  var speed = options.speed || 300;\n\t  options.continuous = options.continuous !== undefined ? options.continuous : true;\n\t\n\t  function setup() {\n\t\n\t    // cache slides\n\t    slides = element.children;\n\t    length = slides.length;\n\t\n\t    // set continuous to false if only one slide\n\t    if (slides.length < 2) options.continuous = false;\n\t\n\t    //special case if two slides\n\t    if (browser.transitions && options.continuous && slides.length < 3) {\n\t      element.appendChild(slides[0].cloneNode(true));\n\t      element.appendChild(element.children[1].cloneNode(true));\n\t      slides = element.children;\n\t    }\n\t\n\t    // create an array to store current positions of each slide\n\t    slidePos = new Array(slides.length);\n\t\n\t    // determine width of each slide\n\t    width = container.getBoundingClientRect().width || container.offsetWidth;\n\t\n\t    element.style.width = (slides.length * width) + 'px';\n\t\n\t    // stack elements\n\t    var pos = slides.length;\n\t    while(pos--) {\n\t\n\t      var slide = slides[pos];\n\t\n\t      slide.style.width = width + 'px';\n\t      slide.setAttribute('data-index', pos);\n\t\n\t      if (browser.transitions) {\n\t        slide.style.left = (pos * -width) + 'px';\n\t        move(pos, index > pos ? -width : (index < pos ? width : 0), 0);\n\t      }\n\t\n\t    }\n\t\n\t    // reposition elements before and after index\n\t    if (options.continuous && browser.transitions) {\n\t      move(circle(index-1), -width, 0);\n\t      move(circle(index+1), width, 0);\n\t    }\n\t\n\t    if (!browser.transitions) element.style.left = (index * -width) + 'px';\n\t\n\t    container.style.visibility = 'visible';\n\t\n\t  }\n\t\n\t  function prev() {\n\t\n\t    if (options.continuous) slide(index-1);\n\t    else if (index) slide(index-1);\n\t\n\t  }\n\t\n\t  function next() {\n\t\n\t    if (options.continuous) slide(index+1);\n\t    else if (index < slides.length - 1) slide(index+1);\n\t\n\t  }\n\t\n\t  function circle(index) {\n\t\n\t    // a simple positive modulo using slides.length\n\t    return (slides.length + (index % slides.length)) % slides.length;\n\t\n\t  }\n\t\n\t  function slide(to, slideSpeed) {\n\t\n\t    // do nothing if already on requested slide\n\t    if (index == to) return;\n\t\n\t    if (browser.transitions) {\n\t\n\t      var direction = Math.abs(index-to) / (index-to); // 1: backward, -1: forward\n\t\n\t      // get the actual position of the slide\n\t      if (options.continuous) {\n\t        var natural_direction = direction;\n\t        direction = -slidePos[circle(to)] / width;\n\t\n\t        // if going forward but to < index, use to = slides.length + to\n\t        // if going backward but to > index, use to = -slides.length + to\n\t        if (direction !== natural_direction) to =  -direction * slides.length + to;\n\t\n\t      }\n\t\n\t      var diff = Math.abs(index-to) - 1;\n\t\n\t      // move all the slides between index and to in the right direction\n\t      while (diff--) move( circle((to > index ? to : index) - diff - 1), width * direction, 0);\n\t\n\t      to = circle(to);\n\t\n\t      move(index, width * direction, slideSpeed || speed);\n\t      move(to, 0, slideSpeed || speed);\n\t\n\t      if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n\t\n\t    } else {\n\t\n\t      to = circle(to);\n\t      animate(index * -width, to * -width, slideSpeed || speed);\n\t      //no fallback for a circular continuous if the browser does not accept transitions\n\t    }\n\t\n\t    index = to;\n\t    offloadFn(options.callback && options.callback(index, slides[index]));\n\t  }\n\t\n\t  function move(index, dist, speed) {\n\t\n\t    translate(index, dist, speed);\n\t    slidePos[index] = dist;\n\t\n\t  }\n\t\n\t  function translate(index, dist, speed) {\n\t\n\t    var slide = slides[index];\n\t    var style = slide && slide.style;\n\t\n\t    if (!style) return;\n\t\n\t    style.webkitTransitionDuration =\n\t    style.MozTransitionDuration =\n\t    style.msTransitionDuration =\n\t    style.OTransitionDuration =\n\t    style.transitionDuration = speed + 'ms';\n\t\n\t    style.webkitTransform = \"translate3d(\" + dist + \"px, 0, 0)\";\n\t    // style.webkitTransform = \"translate3d(0,\" + dist + \"px, 0)\";\n\t    style.msTransform =\n\t    style.MozTransform =\n\t    style.OTransform = 'translateX(' + dist + 'px)';\n\t\n\t  }\n\t\n\t  function animate(from, to, speed) {\n\t\n\t    // if not an animation, just reposition\n\t    if (!speed) {\n\t\n\t      element.style.left = to + 'px';\n\t      return;\n\t\n\t    }\n\t\n\t    var start = +new Date;\n\t\n\t    var timer = setInterval(function() {\n\t\n\t      var timeElap = +new Date - start;\n\t\n\t      if (timeElap > speed) {\n\t\n\t        element.style.left = to + 'px';\n\t\n\t        if (delay) begin();\n\t\n\t        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\t\n\t        clearInterval(timer);\n\t        return;\n\t\n\t      }\n\t\n\t      element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';\n\t\n\t    }, 4);\n\t\n\t  }\n\t\n\t  // setup auto slideshow\n\t  var delay = options.auto || 0;\n\t  var interval;\n\t\n\t  function begin() {\n\t\n\t    interval = setTimeout(next, delay);\n\t\n\t  }\n\t\n\t  function stop() {\n\t    clearTimeout(interval);\n\t  }\n\t\n\t\n\t  // setup initial vars\n\t  var start = {};\n\t  var delta = {};\n\t  var isScrolling;\n\t\n\t  // setup event capturing\n\t  var events = {\n\t\n\t    handleEvent: function(event) {\n\t      switch (event.type) {\n\t        case 'touchstart': this.start(event); break;\n\t        case 'touchmove': this.move(event); break;\n\t        case 'touchend': offloadFn(this.end(event)); break;\n\t        case 'webkitTransitionEnd':\n\t        case 'msTransitionEnd':\n\t        case 'oTransitionEnd':\n\t        case 'otransitionend':\n\t        case 'transitionend': offloadFn(this.transitionEnd(event)); break;\n\t        case 'resize': offloadFn(setup); break;\n\t      }\n\t\n\t      if (options.stopPropagation) event.stopPropagation();\n\t\n\t    },\n\t    start: function(event) {\n\t\n\t      var touches = event.touches[0];\n\t\n\t      // measure start values\n\t      start = {\n\t\n\t        // get initial touch coords\n\t        x: touches.pageX,\n\t        y: touches.pageY,\n\t\n\t        // store time to determine touch duration\n\t        time: +new Date\n\t\n\t      };\n\t\n\t      // used for testing first move event\n\t      isScrolling = undefined;\n\t\n\t      // reset delta and end measurements\n\t      delta = {};\n\t\n\t      // attach touchmove and touchend listeners\n\t      element.addEventListener('touchmove', this, false);\n\t      element.addEventListener('touchend', this, false);\n\t\n\t    },\n\t    move: function(event) {\n\t\n\t      // ensure swiping with one touch and not pinching\n\t      if ( event.touches.length > 1 || event.scale && event.scale !== 1) return\n\t\n\t      if (options.disableScroll) event.preventDefault();\n\t\n\t      var touches = event.touches[0];\n\t\n\t      // measure change in x and y\n\t      delta = {\n\t        x: touches.pageX - start.x,\n\t        y: touches.pageY - start.y\n\t      }\n\t\n\t      // determine if scrolling test has run - one time test\n\t      if ( typeof isScrolling == 'undefined') {\n\t        isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );\n\t      }\n\t\n\t      // if user is not trying to scroll vertically\n\t      if (!isScrolling) {\n\t\n\t        // prevent native scrolling\n\t        event.preventDefault();\n\t\n\t        // stop slideshow\n\t        stop();\n\t\n\t        // increase resistance if first or last slide\n\t        if (options.continuous) { // we don't add resistance at the end\n\t\n\t          translate(circle(index-1), delta.x + slidePos[circle(index-1)], 0);\n\t          translate(index, delta.x + slidePos[index], 0);\n\t          translate(circle(index+1), delta.x + slidePos[circle(index+1)], 0);\n\t\n\t        } else {\n\t\n\t          delta.x =\n\t            delta.x /\n\t              ( (!index && delta.x > 0               // if first slide and sliding left\n\t                || index == slides.length - 1        // or if last slide and sliding right\n\t                && delta.x < 0                       // and if sliding at all\n\t              ) ?\n\t              ( Math.abs(delta.x) / width + 1 )      // determine resistance level\n\t              : 1 );                                 // no resistance if false\n\t\n\t          // translate 1:1\n\t          translate(index-1, delta.x + slidePos[index-1], 0);\n\t          translate(index, delta.x + slidePos[index], 0);\n\t          translate(index+1, delta.x + slidePos[index+1], 0);\n\t        }\n\t\n\t      }\n\t\n\t    },\n\t    end: function(event) {\n\t\n\t      // measure duration\n\t      var duration = +new Date - start.time;\n\t\n\t      // determine if slide attempt triggers next/prev slide\n\t      var isValidSlide =\n\t            Number(duration) < 250               // if slide duration is less than 250ms\n\t            && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px\n\t            || Math.abs(delta.x) > width/2;      // or if slide amt is greater than half the width\n\t\n\t      // determine if slide attempt is past start and end\n\t      var isPastBounds =\n\t            !index && delta.x > 0                            // if first slide and slide amt is greater than 0\n\t            || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0\n\t\n\t      if (options.continuous) isPastBounds = false;\n\t\n\t      // determine direction of swipe (true:right, false:left)\n\t      var direction = delta.x < 0;\n\t\n\t      // if not scrolling vertically\n\t      if (!isScrolling) {\n\t\n\t        if (isValidSlide && !isPastBounds) {\n\t\n\t          if (direction) {\n\t\n\t            if (options.continuous) { // we need to get the next in this direction in place\n\t\n\t              move(circle(index-1), -width, 0);\n\t              move(circle(index+2), width, 0);\n\t\n\t            } else {\n\t              move(index-1, -width, 0);\n\t            }\n\t\n\t            move(index, slidePos[index]-width, speed);\n\t            move(circle(index+1), slidePos[circle(index+1)]-width, speed);\n\t            index = circle(index+1);\n\t\n\t          } else {\n\t            if (options.continuous) { // we need to get the next in this direction in place\n\t\n\t              move(circle(index+1), width, 0);\n\t              move(circle(index-2), -width, 0);\n\t\n\t            } else {\n\t              move(index+1, width, 0);\n\t            }\n\t\n\t            move(index, slidePos[index]+width, speed);\n\t            move(circle(index-1), slidePos[circle(index-1)]+width, speed);\n\t            index = circle(index-1);\n\t\n\t          }\n\t\n\t          options.callback && options.callback(index, slides[index]);\n\t\n\t        } else {\n\t\n\t          if (options.continuous) {\n\t\n\t            move(circle(index-1), -width, speed);\n\t            move(index, 0, speed);\n\t            move(circle(index+1), width, speed);\n\t\n\t          } else {\n\t\n\t            move(index-1, -width, speed);\n\t            move(index, 0, speed);\n\t            move(index+1, width, speed);\n\t          }\n\t\n\t        }\n\t\n\t      }\n\t\n\t      // kill touchmove and touchend event listeners until touchstart called again\n\t      element.removeEventListener('touchmove', events, false)\n\t      element.removeEventListener('touchend', events, false)\n\t\n\t    },\n\t    transitionEnd: function(event) {\n\t\n\t      if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n\t\n\t        if (delay) begin();\n\t\n\t        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\t\n\t      }\n\t\n\t    }\n\t\n\t  }\n\t\n\t  // trigger setup\n\t  setup();\n\t\n\t  // start auto slideshow if applicable\n\t  if (delay) begin();\n\t  //判断屏幕翻转用来重置场景\n\t  var supportsOrientationChange = \"onorientationchange\" in window,\n\t      orientationEvent = supportsOrientationChange ? \"orientationchange\" : \"resize\";\n\t  window.addEventListener(orientationEvent, function(){\n\t    setup();\n\t  }, false);\n\t\n\t  // add event listeners\n\t  if (browser.addEventListener) {\n\t\n\t    // set touchstart event on element\n\t    if (browser.touch) element.addEventListener('touchstart', events, false);\n\t\n\t    if (browser.transitions) {\n\t      element.addEventListener('webkitTransitionEnd', events, false);\n\t      element.addEventListener('msTransitionEnd', events, false);\n\t      element.addEventListener('oTransitionEnd', events, false);\n\t      element.addEventListener('otransitionend', events, false);\n\t      element.addEventListener('transitionend', events, false);\n\t    }\n\t\n\t    // set resize event on window\n\t    window.addEventListener('resize', events, false);\n\t\n\t  } else {\n\t\n\t    window.onresize = function () { setup() }; // to play nice with old IE\n\t\n\t  }\n\t\n\t  // expose the Swipe API\n\t  return {\n\t    setup: function() {\n\t      setup();\n\t    },\n\t    slide: function(to, speed) {\n\t      // cancel slideshow\n\t      stop();\n\t      slide(to, speed);\n\t    },\n\t    prev: function() {\n\t\n\t      // cancel slideshow\n\t      stop();\n\t\n\t      prev();\n\t\n\t    },\n\t    next: function() {\n\t\n\t      // cancel slideshow\n\t      stop();\n\t\n\t      next();\n\t\n\t    },\n\t    stop: function() {\n\t\n\t      // cancel slideshow\n\t      stop();\n\t\n\t    },\n\t    getPos: function() {\n\t\n\t      // return current index position\n\t      return index;\n\t\n\t    },\n\t    getNumSlides: function() {\n\t\n\t      // return total number of slides\n\t      return length;\n\t    },\n\t    kill: function() {\n\t\n\t      // cancel slideshow\n\t      stop();\n\t\n\t      // reset element\n\t      element.style.width = '';\n\t      element.style.left = '';\n\t\n\t      // reset slides\n\t      var pos = slides.length;\n\t      while(pos--) {\n\t\n\t        var slide = slides[pos];\n\t        slide.style.width = '';\n\t        slide.style.left = '';\n\t\n\t        if (browser.transitions) translate(pos, 0, 0);\n\t\n\t      }\n\t\n\t      // removed event listeners\n\t      if (browser.addEventListener) {\n\t\n\t        // remove current event listeners\n\t        element.removeEventListener('touchstart', events, false);\n\t        element.removeEventListener('webkitTransitionEnd', events, false);\n\t        element.removeEventListener('msTransitionEnd', events, false);\n\t        element.removeEventListener('oTransitionEnd', events, false);\n\t        element.removeEventListener('otransitionend', events, false);\n\t        element.removeEventListener('transitionend', events, false);\n\t        window.removeEventListener('resize', events, false);\n\t\n\t      }\n\t      else {\n\t\n\t        window.onresize = null;\n\t\n\t      }\n\t\n\t    }\n\t  }\n\t\n\t}\n\t\n\t\n\t  // if ( window.jQuery || window.Zepto ) {\n\t    // (function($) {\n\t      // $.fn.Swipe = function(params) {\n\t      //   return this.each(function() {\n\t      //     $(this).data('Swipe', new Swipe($(this)[0], params));\n\t      //   });\n\t      // }\n\t    // })( window.jQuery || window.Zepto )\n\t  // }\n\t  // return Swipe;\n\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// coupon.js","/**\n * \n * @authors Your Name (you@example.org)\n * @date    2017-03-05 14:00:03\n * @version $Id$\n */\nrequire('./../css/common/base.css');\nrequire('./../css/coupon.css'); // 载入 style.css\n\nvar zepto = require('zepto'),\n\tSwipe = require('component/swipe.js');\n$(function(){\n\tvar coupon = {\n\t\tinit:function(){\n\t\t\tthis.swipe();\n\t\t\tthis.selectEvent();\n\t\t},\n\t\tselectEvent:function(){\n\t\t\t$('.tab-list li').off('click').on('click',function(){\n\t\t\t\tif($(this).hasClass('cur'))return;\n\t\t\t\tvar index = $(this).index();\n\t\t\t\t$(this).siblings('li').removeClass('cur');\n\t\t\t\t$(this).addClass('cur');\n\t\t\t\tindex == 1 ? confirm.swipe.next() : confirm.swipe.prev();\n\t\t\t})\n\t\t},\t\n\t\tswipe:function(){//轮播图效果\n\t\t\tconfirm.swipe = Swipe(document.getElementById('J_swipe_wp'),{\n\t    \t\tspeed:300,\n\t    \t\tcontinuous:false,\n\t    \t\tauto:0,\n\t    \t\tcallback: function(index, element){\n\t    \t\t\tvar $li = $('.tab-list li');\n\t    \t\t\t$li.removeClass('cur');\n\t    \t\t\t$($li[index]).addClass('cur');\n\t    \t\t\t$(element).find('dl').length ? $('body').addClass('hascoupon').removeClass('nocoupon') : $('body').addClass('nocoupon').removeClass('hascoupon');\n\t    \t\t}\n\t\t\t})\n\t\t}\n\t}\n\tcoupon.init();\n\twindow.coupon = coupon;\n})\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/coupon.js\n// module id = 0\n// module chunks = 3","\n  /*\n * Swipe 2.0\n *\n * Brad Birdsall\n * Copyright 2013, MIT License\n *\n*/\n\nmodule.exports =function (container, options) {\n\n  \"use strict\";\n\n  // utilities\n  var noop = function() {}; // simple no operation function\n  var offloadFn = function(fn) { setTimeout(fn || noop, 0) }; // offload a functions execution\n\n  // check browser capabilities\n  var browser = {\n    addEventListener: !!window.addEventListener,\n    touch: ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch,\n    transitions: (function(temp) {\n      var props = ['transitionProperty', 'WebkitTransition', 'MozTransition', 'OTransition', 'msTransition'];\n      for ( var i in props ) if (temp.style[ props[i] ] !== undefined) return true;\n      return false;\n    })(document.createElement('swipe'))\n  };\n\n  // quit if no root element\n  if (!container) return;\n  var element = container.children[0];\n  var slides, slidePos, width, length;\n  options = options || {};\n  var index = parseInt(options.startSlide, 10) || 0;\n  var speed = options.speed || 300;\n  options.continuous = options.continuous !== undefined ? options.continuous : true;\n\n  function setup() {\n\n    // cache slides\n    slides = element.children;\n    length = slides.length;\n\n    // set continuous to false if only one slide\n    if (slides.length < 2) options.continuous = false;\n\n    //special case if two slides\n    if (browser.transitions && options.continuous && slides.length < 3) {\n      element.appendChild(slides[0].cloneNode(true));\n      element.appendChild(element.children[1].cloneNode(true));\n      slides = element.children;\n    }\n\n    // create an array to store current positions of each slide\n    slidePos = new Array(slides.length);\n\n    // determine width of each slide\n    width = container.getBoundingClientRect().width || container.offsetWidth;\n\n    element.style.width = (slides.length * width) + 'px';\n\n    // stack elements\n    var pos = slides.length;\n    while(pos--) {\n\n      var slide = slides[pos];\n\n      slide.style.width = width + 'px';\n      slide.setAttribute('data-index', pos);\n\n      if (browser.transitions) {\n        slide.style.left = (pos * -width) + 'px';\n        move(pos, index > pos ? -width : (index < pos ? width : 0), 0);\n      }\n\n    }\n\n    // reposition elements before and after index\n    if (options.continuous && browser.transitions) {\n      move(circle(index-1), -width, 0);\n      move(circle(index+1), width, 0);\n    }\n\n    if (!browser.transitions) element.style.left = (index * -width) + 'px';\n\n    container.style.visibility = 'visible';\n\n  }\n\n  function prev() {\n\n    if (options.continuous) slide(index-1);\n    else if (index) slide(index-1);\n\n  }\n\n  function next() {\n\n    if (options.continuous) slide(index+1);\n    else if (index < slides.length - 1) slide(index+1);\n\n  }\n\n  function circle(index) {\n\n    // a simple positive modulo using slides.length\n    return (slides.length + (index % slides.length)) % slides.length;\n\n  }\n\n  function slide(to, slideSpeed) {\n\n    // do nothing if already on requested slide\n    if (index == to) return;\n\n    if (browser.transitions) {\n\n      var direction = Math.abs(index-to) / (index-to); // 1: backward, -1: forward\n\n      // get the actual position of the slide\n      if (options.continuous) {\n        var natural_direction = direction;\n        direction = -slidePos[circle(to)] / width;\n\n        // if going forward but to < index, use to = slides.length + to\n        // if going backward but to > index, use to = -slides.length + to\n        if (direction !== natural_direction) to =  -direction * slides.length + to;\n\n      }\n\n      var diff = Math.abs(index-to) - 1;\n\n      // move all the slides between index and to in the right direction\n      while (diff--) move( circle((to > index ? to : index) - diff - 1), width * direction, 0);\n\n      to = circle(to);\n\n      move(index, width * direction, slideSpeed || speed);\n      move(to, 0, slideSpeed || speed);\n\n      if (options.continuous) move(circle(to - direction), -(width * direction), 0); // we need to get the next in place\n\n    } else {\n\n      to = circle(to);\n      animate(index * -width, to * -width, slideSpeed || speed);\n      //no fallback for a circular continuous if the browser does not accept transitions\n    }\n\n    index = to;\n    offloadFn(options.callback && options.callback(index, slides[index]));\n  }\n\n  function move(index, dist, speed) {\n\n    translate(index, dist, speed);\n    slidePos[index] = dist;\n\n  }\n\n  function translate(index, dist, speed) {\n\n    var slide = slides[index];\n    var style = slide && slide.style;\n\n    if (!style) return;\n\n    style.webkitTransitionDuration =\n    style.MozTransitionDuration =\n    style.msTransitionDuration =\n    style.OTransitionDuration =\n    style.transitionDuration = speed + 'ms';\n\n    style.webkitTransform = \"translate3d(\" + dist + \"px, 0, 0)\";\n    // style.webkitTransform = \"translate3d(0,\" + dist + \"px, 0)\";\n    style.msTransform =\n    style.MozTransform =\n    style.OTransform = 'translateX(' + dist + 'px)';\n\n  }\n\n  function animate(from, to, speed) {\n\n    // if not an animation, just reposition\n    if (!speed) {\n\n      element.style.left = to + 'px';\n      return;\n\n    }\n\n    var start = +new Date;\n\n    var timer = setInterval(function() {\n\n      var timeElap = +new Date - start;\n\n      if (timeElap > speed) {\n\n        element.style.left = to + 'px';\n\n        if (delay) begin();\n\n        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\n        clearInterval(timer);\n        return;\n\n      }\n\n      element.style.left = (( (to - from) * (Math.floor((timeElap / speed) * 100) / 100) ) + from) + 'px';\n\n    }, 4);\n\n  }\n\n  // setup auto slideshow\n  var delay = options.auto || 0;\n  var interval;\n\n  function begin() {\n\n    interval = setTimeout(next, delay);\n\n  }\n\n  function stop() {\n    clearTimeout(interval);\n  }\n\n\n  // setup initial vars\n  var start = {};\n  var delta = {};\n  var isScrolling;\n\n  // setup event capturing\n  var events = {\n\n    handleEvent: function(event) {\n      switch (event.type) {\n        case 'touchstart': this.start(event); break;\n        case 'touchmove': this.move(event); break;\n        case 'touchend': offloadFn(this.end(event)); break;\n        case 'webkitTransitionEnd':\n        case 'msTransitionEnd':\n        case 'oTransitionEnd':\n        case 'otransitionend':\n        case 'transitionend': offloadFn(this.transitionEnd(event)); break;\n        case 'resize': offloadFn(setup); break;\n      }\n\n      if (options.stopPropagation) event.stopPropagation();\n\n    },\n    start: function(event) {\n\n      var touches = event.touches[0];\n\n      // measure start values\n      start = {\n\n        // get initial touch coords\n        x: touches.pageX,\n        y: touches.pageY,\n\n        // store time to determine touch duration\n        time: +new Date\n\n      };\n\n      // used for testing first move event\n      isScrolling = undefined;\n\n      // reset delta and end measurements\n      delta = {};\n\n      // attach touchmove and touchend listeners\n      element.addEventListener('touchmove', this, false);\n      element.addEventListener('touchend', this, false);\n\n    },\n    move: function(event) {\n\n      // ensure swiping with one touch and not pinching\n      if ( event.touches.length > 1 || event.scale && event.scale !== 1) return\n\n      if (options.disableScroll) event.preventDefault();\n\n      var touches = event.touches[0];\n\n      // measure change in x and y\n      delta = {\n        x: touches.pageX - start.x,\n        y: touches.pageY - start.y\n      }\n\n      // determine if scrolling test has run - one time test\n      if ( typeof isScrolling == 'undefined') {\n        isScrolling = !!( isScrolling || Math.abs(delta.x) < Math.abs(delta.y) );\n      }\n\n      // if user is not trying to scroll vertically\n      if (!isScrolling) {\n\n        // prevent native scrolling\n        event.preventDefault();\n\n        // stop slideshow\n        stop();\n\n        // increase resistance if first or last slide\n        if (options.continuous) { // we don't add resistance at the end\n\n          translate(circle(index-1), delta.x + slidePos[circle(index-1)], 0);\n          translate(index, delta.x + slidePos[index], 0);\n          translate(circle(index+1), delta.x + slidePos[circle(index+1)], 0);\n\n        } else {\n\n          delta.x =\n            delta.x /\n              ( (!index && delta.x > 0               // if first slide and sliding left\n                || index == slides.length - 1        // or if last slide and sliding right\n                && delta.x < 0                       // and if sliding at all\n              ) ?\n              ( Math.abs(delta.x) / width + 1 )      // determine resistance level\n              : 1 );                                 // no resistance if false\n\n          // translate 1:1\n          translate(index-1, delta.x + slidePos[index-1], 0);\n          translate(index, delta.x + slidePos[index], 0);\n          translate(index+1, delta.x + slidePos[index+1], 0);\n        }\n\n      }\n\n    },\n    end: function(event) {\n\n      // measure duration\n      var duration = +new Date - start.time;\n\n      // determine if slide attempt triggers next/prev slide\n      var isValidSlide =\n            Number(duration) < 250               // if slide duration is less than 250ms\n            && Math.abs(delta.x) > 20            // and if slide amt is greater than 20px\n            || Math.abs(delta.x) > width/2;      // or if slide amt is greater than half the width\n\n      // determine if slide attempt is past start and end\n      var isPastBounds =\n            !index && delta.x > 0                            // if first slide and slide amt is greater than 0\n            || index == slides.length - 1 && delta.x < 0;    // or if last slide and slide amt is less than 0\n\n      if (options.continuous) isPastBounds = false;\n\n      // determine direction of swipe (true:right, false:left)\n      var direction = delta.x < 0;\n\n      // if not scrolling vertically\n      if (!isScrolling) {\n\n        if (isValidSlide && !isPastBounds) {\n\n          if (direction) {\n\n            if (options.continuous) { // we need to get the next in this direction in place\n\n              move(circle(index-1), -width, 0);\n              move(circle(index+2), width, 0);\n\n            } else {\n              move(index-1, -width, 0);\n            }\n\n            move(index, slidePos[index]-width, speed);\n            move(circle(index+1), slidePos[circle(index+1)]-width, speed);\n            index = circle(index+1);\n\n          } else {\n            if (options.continuous) { // we need to get the next in this direction in place\n\n              move(circle(index+1), width, 0);\n              move(circle(index-2), -width, 0);\n\n            } else {\n              move(index+1, width, 0);\n            }\n\n            move(index, slidePos[index]+width, speed);\n            move(circle(index-1), slidePos[circle(index-1)]+width, speed);\n            index = circle(index-1);\n\n          }\n\n          options.callback && options.callback(index, slides[index]);\n\n        } else {\n\n          if (options.continuous) {\n\n            move(circle(index-1), -width, speed);\n            move(index, 0, speed);\n            move(circle(index+1), width, speed);\n\n          } else {\n\n            move(index-1, -width, speed);\n            move(index, 0, speed);\n            move(index+1, width, speed);\n          }\n\n        }\n\n      }\n\n      // kill touchmove and touchend event listeners until touchstart called again\n      element.removeEventListener('touchmove', events, false)\n      element.removeEventListener('touchend', events, false)\n\n    },\n    transitionEnd: function(event) {\n\n      if (parseInt(event.target.getAttribute('data-index'), 10) == index) {\n\n        if (delay) begin();\n\n        options.transitionEnd && options.transitionEnd.call(event, index, slides[index]);\n\n      }\n\n    }\n\n  }\n\n  // trigger setup\n  setup();\n\n  // start auto slideshow if applicable\n  if (delay) begin();\n  //判断屏幕翻转用来重置场景\n  var supportsOrientationChange = \"onorientationchange\" in window,\n      orientationEvent = supportsOrientationChange ? \"orientationchange\" : \"resize\";\n  window.addEventListener(orientationEvent, function(){\n    setup();\n  }, false);\n\n  // add event listeners\n  if (browser.addEventListener) {\n\n    // set touchstart event on element\n    if (browser.touch) element.addEventListener('touchstart', events, false);\n\n    if (browser.transitions) {\n      element.addEventListener('webkitTransitionEnd', events, false);\n      element.addEventListener('msTransitionEnd', events, false);\n      element.addEventListener('oTransitionEnd', events, false);\n      element.addEventListener('otransitionend', events, false);\n      element.addEventListener('transitionend', events, false);\n    }\n\n    // set resize event on window\n    window.addEventListener('resize', events, false);\n\n  } else {\n\n    window.onresize = function () { setup() }; // to play nice with old IE\n\n  }\n\n  // expose the Swipe API\n  return {\n    setup: function() {\n      setup();\n    },\n    slide: function(to, speed) {\n      // cancel slideshow\n      stop();\n      slide(to, speed);\n    },\n    prev: function() {\n\n      // cancel slideshow\n      stop();\n\n      prev();\n\n    },\n    next: function() {\n\n      // cancel slideshow\n      stop();\n\n      next();\n\n    },\n    stop: function() {\n\n      // cancel slideshow\n      stop();\n\n    },\n    getPos: function() {\n\n      // return current index position\n      return index;\n\n    },\n    getNumSlides: function() {\n\n      // return total number of slides\n      return length;\n    },\n    kill: function() {\n\n      // cancel slideshow\n      stop();\n\n      // reset element\n      element.style.width = '';\n      element.style.left = '';\n\n      // reset slides\n      var pos = slides.length;\n      while(pos--) {\n\n        var slide = slides[pos];\n        slide.style.width = '';\n        slide.style.left = '';\n\n        if (browser.transitions) translate(pos, 0, 0);\n\n      }\n\n      // removed event listeners\n      if (browser.addEventListener) {\n\n        // remove current event listeners\n        element.removeEventListener('touchstart', events, false);\n        element.removeEventListener('webkitTransitionEnd', events, false);\n        element.removeEventListener('msTransitionEnd', events, false);\n        element.removeEventListener('oTransitionEnd', events, false);\n        element.removeEventListener('otransitionend', events, false);\n        element.removeEventListener('transitionend', events, false);\n        window.removeEventListener('resize', events, false);\n\n      }\n      else {\n\n        window.onresize = null;\n\n      }\n\n    }\n  }\n\n}\n\n\n  // if ( window.jQuery || window.Zepto ) {\n    // (function($) {\n      // $.fn.Swipe = function(params) {\n      //   return this.each(function() {\n      //     $(this).data('Swipe', new Swipe($(this)[0], params));\n      //   });\n      // }\n    // })( window.jQuery || window.Zepto )\n  // }\n  // return Swipe;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/js/component/swipe.js\n// module id = 14\n// module chunks = 3 4 7 8 9 10"],"sourceRoot":""}